{
    "title": "친절한 SQL 튜닝",
    "introduce": "책 제목은 필자가 애청하는 라디오 프로그램 ‘손에 잡히는 경제’ 중 ‘친절한 경제’라는 코너에서 착안했다. 어려운 경제 이슈를 일반인 눈높이에 맞게 풀어서 설명해 주는 진행자를 보면서 “나도 SQL 성능 문제를 저렇게 쉽게 풀어 설명하는 책을 써야겠다”는 다짐을 했다. 전작 ‘오라클 성능 고도화 원리와 해법’은 원래 개발자를 위해 쓴 책이었는데, 애초의 생각보다 DB 아키텍처를 너무 깊게 다루다 보니 개발자보다 오히려 DBA와 튜닝 전문가들이 더 많이 보는 책이 돼 버렸다. 그래서 새로 만든 책이 ‘친절한 SQL 튜닝’이다. 군더더기를 제거하고 핵심만 간추려서 개발자 눈높이에 맞게 친절하고 쉽게 풀어쓴 오라클 성능 고도화!\n\n‘친절한 SQL 튜닝’은 개발자를 위한 SQL 튜닝 입문서다. 20년 가까이 DB 성능 컨설팅을 수행한 현직 튜너로서 개발자에게 들려주고 싶은 DB 성능 이야기를 담았다. 핵심 성능 이론은 변하지 않으므로 일부 전작에서 그대로 차용한 내용도 있지만, 그림을 보충하고 더 쉽고 친절하게 설명하려고 노력했다. 그렇다고 DB 프로그래밍 초보자를 위한 책은 아니다. 어느 정도 경력이 쌓였는데도 성능 문제를 스스로 해결하지 못해 늘 고민하는 분들을 위한 책이다. 국가공인 SQLP(SQL 전문가) 자격검정의 핵심이론을 집중적으로 다루었으므로 이 자격증에 도전하는 분들에게도 좋은 참고서가 되리라고 믿는다. 오라클 중심으로 설명하지만, 대부분 DBMS에 공통으로 적용되는 성능 원리를 다루므로 오라클 경험이 없는 개발자도 따라오는 데 문제는 없다. 아무쪼록 정보시스템을 구축하고 운영하는 모든 개발자가 이 책을 통해 SQL 튜닝의 비밀스러운 세계를 경험하고 그 매력에 흠뻑 빠져들기를 바란다.\n\n내용 문의 http://www.dbian.net",
    "toc": "1장. SQL 처리 과정과 I/O\n1.1 SQL 파싱과 최적화\n1.1.1 구조적, 집합적, 선언적 질의 언어\n1.1.2 SQL 최적화\n1.1.3 SQL 옵티마이저\n1.1.4 실행계획과 비용\n1.1.5 옵티마이저 힌트\n\n1.2 SQL 공유 및 재사용\n1.2.1 소프트 파싱 vs. 하드 파싱\n1.2.2 바인드 변수의 중요성\n\n1.3 데이터 저장 구조 및 I/O 메커니즘\n1.3.1 SQL이 느린 이유\n1.3.2 데이터베이스 저장 구조\n1.3.3 블록 단위 I/O\n1.3.4 시퀀셜 액세스 vs. 랜덤 액세스\n1.3.5 논리적 I/O vs. 물리적 I/O\n1.3.6 Single Block I/O vs. Multiblock I/O\n1.3.7 Table Full Scan vs. Index Range Scan\n1.3.8 캐시 탐색 메커니즘\n\n\n2장. 인덱스 기본\n2.1 인덱스 구조 및 탐색\n2.1.1 미리 보는 인덱스 튜닝\n2.1.2 인덱스 구조\n2.1.3 인덱스 수직적 탐색\n2.1.4 인덱스 수평적 탐색\n2.1.5 결합 인덱스 구조와 탐색\n\n2.2 인덱스 기본 사용법\n2.2.1 인덱스를 사용한다는 것\n2.2.2 인덱스를 Range Scan 할 수 없는 이유\n2.2.3 더 중요한 인덱스 사용 조건\n2.2.4 인덱스를 이용한 소트 연산 생략\n2.2.5 ORDER BY 절에서 컬럼 가공\n2.2.6 SELECT-LIST에서 컬럼 가공\n2.2.7 자동 형변환\n\n2.3 인덱스 확장기능 사용법\n2.3.1 Index Range Scan\n2.3.2 Index Full Scan\n2.3.3 Index Unique Scan\n2.3.4 Index Skip Scan\n2.3.5 Index Fast Full Scan\n2.3.6 Index Range Scan Descending\n\n\n3장. 인덱스 튜닝\n3.1 테이블 액세스 최소화\n3.1.1 테이블 랜덤 액세스\n3.1.2 인덱스 클러스터링 팩터\n3.1.3 인덱스 손익분기점\n3.1.4 인덱스 컬럼 추가\n3.1.5 인덱스만 읽고 처리\n3.1.6 인덱스 구조 테이블\n3.1.7 클러스터 테이블\n\n3.2 부분범위 처리 활용\n3.2.1 부분범위 처리\n3.2.2 부분범위 처리 구현\n3.2.3 OLTP 환경에서 부분범위 처리에 의한 성능개선 원리\n\n3.3 인덱스 스캔 효율화\n3.3.1 인덱스 탐색\n3.3.2 인덱스 스캔 효율성\n3.3.3 액세스 조건과 필터 조건\n3.3.4 비교 연산자 종류와 컬럼 순서에 따른 군집성\n3.3.5 인덱스 선행 컬럼이 등치(=) 조건이 아닐 때 생기는 비효율\n3.3.6 BETWEEN을 IN-List로 전환\n3.3.7 Index Skip Scan 활용\n3.3.8 IN 조건은 ‘=’인가\n3.3.9 BETWEEN과 LIKE 스캔 범위 비교\n3.3.10 범위검색 조건을 남용할 때 생기는 비효율\n3.3.11 다양한 옵션 조건 처리 방식의 장단점 비교\n3.3.12 함수호출부하 해소를 위한 인덱스 구성\n\n3.4 인덱스 설계\n3.4.1 인덱스 설계가 어려운 이유\n3.4.2 가장 중요한 두 가지 선택 기준\n3.4.3 스캔 효율성 이외의 판단 기준\n3.4.4 공식을 초월한 전략적 설계\n3.4.5 소트 연산을 생략하기 위한 컬럼 추가\n3.4.6 결합 인덱스 선택도\n3.4.7 중복 인덱스 제거\n3.4.8 인덱스 설계도 작성\n\n\n4장. 조인 튜닝\n4.1 NL 조인\n4.1.1 기본 메커니즘\n4.1.2 NL 조인 실행계획 제어\n4.1.3 NL 조인 수행 과정 분석\n4.1.4 NL 조인 튜닝 포인트\n4.1.5 NL 조인 특징 요약\n4.1.6 NL 조인 튜닝 실습\n4.1.7 NL 조인 확장 메커니즘\n\n4.2 소트 머지 조인\n4.2.1 SGA vs. PGA\n4.2.2 기본 메커니즘\n4.2.3 소트 머지 조인이 빠른 이유\n4.2.4 소트 머지 조인의 주용도\n4.2.5 소트 머지 조인 제어하기\n4.2.6 소트 머지 조인 특징 요약\n\n4.3 해시 조인\n4.3.1 기본 메커니즘\n4.3.2 해시 조인이 빠른 이유\n4.3.3 대용량 Build Input 처리\n4.3.4 해시 조인 실행계획 제어\n4.3.5 조인 메소드 선택 기준\n\n4.4 서브쿼리 조인\n4.4.1 서브쿼리 변환이 필요한 이유\n4.4.2 서브쿼리와 조인\n4.4.3 뷰(View)와 조인\n4.4.4 스칼라 서브쿼리 조인\n\n\n5장. 소트 튜닝\n5.1 소트 연산에 대한 이해\n5.1.1 소트 수행 과정\n5.1.2 소트 오퍼레이션\n\n5.2 소트가 발생하지 않도록 SQL 작성\n5.2.1 Union vs. Union All\n5.2.2 Exists 활용\n\n5.3 인덱스를 이용한 소트 연산 생략\n5.3.1 Sort Order By 생략\n5.3.2 Top N 쿼리\n5.3.3 최소값/최대값 구하기\n5.3.4 이력 조회\n5.3.5 Sort Group By 생략\n\n5.4 Sort Area를 적게 사용하도록 SQL 작성\n5.4.1 소트 데이터 줄이기\n5.4.2 Top N 쿼리의 소트 부하 경감 원리\n5.4.3 Top N 쿼리가 아닐 때 발생하는 소트 부하\n5.4.4 분석함수에서의 Top N 소트\n\n\n6장. DML 튜닝\n6.1 기본 DML 튜닝\n6.1.1 DML 성능에 영향을 미치는 요소\n6.1.2 데이터베이스 Call과 성능\n6.1.3 Array Processing 활용\n6.1.4 인덱스 및 제약 해제를 통한 대량 DML 튜닝\n6.1.5 수정가능 조인 뷰\n6.1.6 MERGE 문 활용\n\n6.2 Direct Path I/O 활용\n6.2.1 Direct Path I/O\n6.2.2 Direct Path Insert\n6.2.3 병렬 DML\n\n6.3 파티션을 활용한 DML 튜닝\n6.3.1 테이블 파티션\n6.3.2 인덱스 파티션\n6.3.3 파티션을 활용한 대량 UPDATE 튜닝\n6.3.4 파티션을 활용한 대량 DELETE 튜닝\n6.3.5 파티션을 활용한 대량 INSERT 튜닝\n\n6.4 Lock과 트랜잭션 동시성 제어\n6.4.1 오라클 Lock\n6.4.2 트랜잭션 동시성 제어\n6.4.3 채번 방식에 따른 INSERT 성능 비교\n\n\n7장. SQL 옵티마이저\n7.1 통계정보와 비용 계산 원리\n7.1.1 선택도와 카디널리티\n7.1.2 통계정보\n7.1.3 비용 계산 원리\n\n7.2 옵티마이저에 대한 이해\n7.2.1 옵티마이저 종류\n7.2.2 옵티마이저 모드\n7.2.3 옵티마이저에 영향을 미치는 요소\n7.2.4 옵티마이저의 한계\n7.2.5 개발자의 역할\n7.2.6 튜닝 전문가 되는 공부방법\n\n부록. SQL 분석 도구\n1. 실행계획 확인\n2. AutoTrace\n3. SQL 트레이스\n4. DBMS_XPLAN 패키지\n5. 실시간 SQL 모니터링\n6. V$SQL"
}