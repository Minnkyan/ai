{
    "title": "가장 빠른 풀스택을 위한 Flask & FastAPI",
    "introduce": "가장 빠른 웹 개발과 풀스택을 위한 Flask와 FastAPI\n\n파이썬 기반 웹 프레임워크는 자바(Java)로의 복잡한 구현에 버금가는 좋은 성능의 결과물을 도출하면서도 개발 기간을 획기적으로 단축시킬 수 있다. 따라서 세계적으로 인기를 누린 지는 이미 오래되었고 국내에서의 니즈도 점차 활발해지고 있다. 또한 파이썬 자체가 꾸준히 개선되며 생산성과 성능, 두 마리 토끼를 잡을 수 있는 기술로 대두되고 있다.\n\n플라스크(Flask), FastAPI와 함께라면 이전보다 빠르고, 가볍고, 세련된 웹과 풀스택을 기대해도 좋다. 이 책을 통해 방대한 예시와 실전에서 바로 활용할 수 있는 프로젝트를 직접 경험해보고, 배우기 쉽고 현대적인 웹에 적합한 파이썬 기반 웹 프레임워크 기술을 자신만의 무기로 갖춰보자.",
    "toc": "제1장 플라스크와 FastAPI 이해하기\n\n_1.1 웹 서비스의 역사와 동향\n_1.2 마이크로 프레임워크란?\n_1.3 플라스크란 무엇인가?\n_1.4 FastAPI란 무엇인가?\n\n제2장 플라스크 시작하기\n\n_2.1 개발 환경 구축\n__2.1.1 아나콘다\n__2.1.2 비주얼 스튜디오 코드\n__2.1.3 curl 명령어\n_2.2 안녕, 플라스크!\n__2.2.1 Hello, World! 애플리케이션 만들기\n__2.2.2 flask run 상세 사용법\n__2.2.3 flask run의 추가 옵션\n__2.2.4 플라스크 애플리케이션 접속 주소\n_2.3 라우팅\n__2.3.1 플라스크에서의 라우팅\n__2.3.2 URL 변수\n__2.3.3 HTTP 메서드\n__2.3.4 URL 빌더\n__2.3.5 타입 힌트를 활용한 라우팅\n_2.4 요청과 응답\n__2.4.1 플라스크에서의 요청 처리\n__2.4.2 플라스크에서의 응답 처리\n__2.4.3 JSON이란 무엇인가?\n__2.4.4 상태 코드와 헤더 설정\n_2.5 템플릿\n__2.5.1 템플릿 기본 사용법\n__2.5.2 변수와 제어문\n__2.5.3 필터\n__2.5.4 반복문\n__2.5.5 매크로\n__2.5.6 템플릿 상속\n_2.6 정적 파일\n__2.6.1 플라스크에서 정적 파일 다루기\n__2.6.2 정적 파일과 웹페이지 구현\n__2.6.3 기존 웹페이지 통합\n_2.7 블루프린트\n__2.7.1 왜 블루프린트가 필요한가?\n__2.7.2 블루프린트 기본 사용법\n__2.7.3 애플리케이션 구조 모듈화하기\n_2.8 세션과 쿠키\n__2.8.1 세션과 쿠키의 필요성\n__2.8.2 플라스크에서의 세션 사용법\n__2.8.3 플라스크에서의 쿠키 사용법\n_2.9 로깅\n__2.9.1 왜 로깅이 필요한가?\n__2.9.2 로깅 기본 사용법\n\n\n\n_3.1 데이터베이스\n__3.1.1 플라스크와 MySQL 연동\n__3.1.2 Flask-Migrate\n_3.2 인증과 세션\n__3.2.1 인증과 세션이란?\n__3.2.2 플라스크에서의 인증과 세션\n__3.2.3 Flask-Login을 사용한 인증\n__3.2.4 예제로 이해하는 인증\n__3.2.5 세션을 이용한 상태 관리\n__3.2.6 예제로 이해하는 세션\n_3.3 RESTful API\n__3.3.1 HTTP 메서드 이해하기\n__3.3.2 RESTful API 구현하기\n_3.4 캐싱\n__3.4.1 캐싱이란 무엇인가?\n__3.4.2 캐싱 구현하기\n_3.5 배포\n__3.5.1 웹 서버와 SGI\n__3.5.2 WSGI를 지원하는 플라스크\n__3.5.3 Gunicorn으로 플라스크 애플리케이션 배포하기\n_3.6 테스팅\n__3.6.1 플라스크에서의 테스팅\n__3.6.2 테스트 실행하기\n__3.6.3 unittest의 다양한 기능\n_3.7 플라스크 성능 개선 팁\n__3.7.1 데이터베이스 쿼리 최적화\n__3.7.2 정적 파일 최적화 및 캐싱의 진화된 전략\n__3.7.3 로깅을 활용한 효과적인 디버깅\n__3.7.4 고도화된 코드 최적화 기법\n\n\n\n_4.1 첫 번째 코드: 플라스크 애플리케이션 생성\n__4.1.1 플라스크 애플리케이션 생성 및 flask run 설정\n__4.1.2 flask run을 사용한 애플리케이션 실행\n_4.2 두 번째 코드: 템플릿 사용과 라우팅 확장\n__4.2.1 HTML 템플릿 생성\n__4.2.2 플라스크 애플리케이션에서 템플릿 렌더링\n__4.2.3 추가적인 라우팅 설정\n__4.2.4 애플리케이션 실행 및 테스트\n_4.3 세 번째 코드: 데이터베이스 연동 및 CRUD 구현\n__4.3.1 데이터베이스 연동 및 모델 정의\n__4.3.2 CRUD 기능 구현\n__4.3.3 CRUD 기능 테스트\n_4.4 네 번째 코드: 사용자 인증\n__4.4.1 Flask-Login을 활용한 사용자 인증 구현\n__4.4.2 사용자 인증 테스트\n_4.5 다섯 번째 코드: 사용자별 메모 관리\n__4.5.1 사용자별 메모 관리 구현\n__4.5.2 memos.html 작성\n__4.5.3 메모 관리 기능 테스트\n_4.6 여섯 번째 코드: 웹페이지 개선\n__4.6.1 home.html 작성\n__4.6.2 memos.html 작성\n__4.6.3 테스트\n_4.7 일곱 번째 코드: 사용자 편의성 향상\n__4.7.1 로그인 기능 개선\n__4.7.2 회원가입 기능 개선\n__4.7.3 프런트엔드 페이지 수정\n__4.7.4 로그아웃 기능 개선\n__4.7.5 테스트\n_4.8 여덟 번째 코드: MVC 패턴 적용\n__4.8.1 현재 app.py 파일 구조\n__4.8.2 MVC 패턴 적용\n플라스크를 마치며\n\n\n\n_5.1 안녕, FastAPI!\n__5.1.1 Hello, World! API 만들기\n__5.1.2 자동 문서화\n_5.2 라우팅\n__5.2.1 기본 라우팅\n__5.2.2 경로 매개변수\n__5.2.3 쿼리 매개변수\n__5.2.4 curl을 사용한 테스트\n_5.3 타입 힌트\n__5.3.1 기본 타입 힌트\n__5.3.2 고급 타입 힌트\n__5.3.3 타입 힌트로 사용 가능한 데이터 타입\n_5.4 HTTP 메서드\n__5.4.1 FastAPI 코드 작성\n__5.4.2 curl을 사용한 테스트\n_5.5 Pydantic\n__5.5.1 Pydantic 모델 적용\n__5.5.2 Pydantic 기본 문법\n__5.5.3 중첩된 모델\n__5.5.4 List와 Union\n_5.6 FastAPI 응답 모델\n__5.6.1 기본 응답 모델\n__5.6.2 Generic 응답 모델\n__5.6.3 Union 응답 모델\n__5.6.4 List 응답 모델\n_5.7 FastAPI 응답 클래스\n__5.7.1 HTMLResponse 예제 코드\n__5.7.2 PlainTextResponse 예제 코드\n__5.7.3 RedirectResponse 예제 코드\n_5.8 요청\n__5.8.1 FastAPI에서 쿼리 매개변수 다루기\n__5.8.2 Query 클래스의 주요 옵션\n__5.8.3 요청 바디\n_5.9 예외 처리\n__5.9.1 기본 예외 처리\n__5.9.2 HTTPException 클래스\n__5.9.3 HTTP 헤더\n\n\n\n_6.1 템플릿\n__6.1.1 FastAPI 설정\n__6.1.2 템플릿 렌더링\n__6.1.3 username을 요청에서 받기\n__6.1.4 FastAPI와 Jinja2의 기본 문법\n__6.1.5 FastAPI와 Jinja2의 고급 문법\n_6.2 정적 파일\n__6.2.1 FastAPI에서 정적 파일 다루기\n__6.2.2 정적 파일과 웹페이지 구현\n__6.2.3 기존 웹페이지 통합\n_6.3 APIRouter\n__6.3.1 다양한 사용법\n__6.3.2 미들웨어 설정\n__6.3.3 APIRouter와 의존성 함수\n__6.3.4 APIRouter와 라우트 설정의 상속\n__6.3.5 APIRouter와 플라스크 블루프린트의 비교\n_6.4 쿼리 매개변수와 경로 매개변수\n__6.4.1 쿼리 매개변수\n__6.4.2 경로 매개변수\n__6.4.3 타입 지정과 경로 매개변수 연산자\n_6.5 백그라운드 태스크\n_6.6 스트리밍 응답\n_6.7 웹소켓\n__6.7.1 웹소켓 기본 사용법\n__6.7.2 웹소켓 주요 메서드\n\n\n\n_7.1 데이터베이스와 ORM\n__7.1.1 FastAPI와 MySQL 연동\n__7.1.2 SQLAlchemy와 CRUD\n_7.2 인증과 세션\n__7.2.1 기본 인증 메커니즘 이해하기\n__7.2.2 고급 인증1: JWT\n__7.2.3 고급 인증2: 세션\n_7.3 비동기 처리\n_7.4 파일 업로드\n_7.5 캐싱과 미들웨어\n__7.5.1 FastAPI 캐싱\n__7.5.2 FastAPI 주요 미들웨어\n_7.6 배포\n__7.6.1 Uvicorn 설치 및 실행\n__7.6.2 도커로 FastAPI 애플리케이션 배포하기\n_7.7 FastAPI 성능 개선 팁\n__7.7.1 비동기 프로그래밍 활용\n__7.7.2 캐싱 활용\n__7.7.3 데이터베이스 커넥션 풀링\n\n\n\n_8.1 라우팅\n__8.1.1 플라스크의 라우팅\n__8.1.2 FastAPI의 라우팅\n_8.2 타입 힌팅\n__8.2.1 플라스크의 타입 힌팅\n__8.2.2 FastAPI의 타입 힌팅\n__8.2.3 주요 차이점\n_8.3 요청과 응답\n__8.3.1 플라스크의 요청과 응답\n__8.3.2 FastAPI의 요청과 응답\n__8.3.3 주요 차이점\n_8.4 데이터베이스\n__8.4.1 플라스크의 PyMySQL과 SQLAlchemy\n__8.4.2 FastAPI의 PyMySQL과 SQLAlchemy\n__8.4.3 주요 차이점\n_8.5 세션 관리\n__8.5.1 플라스크의 세션 관리\n__8.5.2 FastAPI의 세션 관리\n__8.5.3 주요 차이점\n_8.6 비동기 처리\n__8.6.1 플라스크의 비동기 처리\n__8.6.2 FastAPI의 비동기 처리\n\n\n\n_9.1 첫 번째 코드: FastAPI 애플리케이션 생성\n__9.1.1 FastAPI 설치 및 프로젝트 구조 설정\n__9.1.2 FastAPI 애플리케이션 생성 및 Uvicorn 설정\n__9.1.3 Uvicorn을 사용한 애플리케이션 실행\n_9.2 두 번째 코드: Jinja2 템플릿 사용과 라우팅 확장\n__9.2.1 HTML 템플릿 생성 및 Jinja2 설치\n__9.2.2 FastAPI 애플리케이션에서 템플릿 렌더링\n__9.2.3 추가적인 라우팅 설정\n__9.2.4 애플리케이션 실행 및 테스트\n_9.3 세 번째 코드: 데이터베이스 연동 및 CRUD 구현\n__9.3.1 데이터베이스 연동 및 모델 정의\n__9.3.2 CRUD 기능 구현\n__9.3.3 CRUD 기능 테스트\n_9.4 네 번째 코드: 사용자 인증\n__9.4.1 MySQL을 연동한 사용자 인증 구현\n__9.4.2 사용자 인증 테스트\n_9.5 다섯 번째 코드: 사용자별 메모 관리\n__9.5.1 사용자별 메모 관리 구현\n__9.5.2 memos.html 작성\n__9.5.3 메모 관리 기능 테스트\n_9.6 여섯 번째 코드: 웹페이지 개선\n__9.6.1 home.html 작성\n__9.6.2 memos.html 작성\n__9.6.3 테스트\n_9.7 일곱 번째 코드: 마무리\n__9.7.1 프런트엔드 페이지 개선\n__9.7.2 예외 케이스 보완\n__9.7.3 테스트\n_9.8 여덟 번째 코드: MVC 패턴 적용\n__9.8.1 MVC 패턴에 따른 파일 구조 및 역할\n__9.8.2 MVC 패턴 적용\nFastAPI를 마치며"
}